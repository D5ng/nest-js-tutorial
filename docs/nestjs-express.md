# NestJS 특징 및 Express 비교

NestJS가 **무엇**인지보다, **왜** 이런 구조를 갖게 됐는지, Express와 비교했을 때 어떤 트레이드오프가 있는지 정리한 문서예요.

---

## 1. NestJS가 풀려는 문제

Express는 “라우트 하나씩 등록하고, 미들웨어 끼워 넣고, 요청/응답 객체만 넘겨준다”는 **최소 규칙**만 제공해요. 그래서:

- 폴더 구조·레이어 분리는 팀이 정해서 써야 하고, 프로젝트마다 다를 수 있음.
- “이 로직은 서비스에 둘까, 컨트롤러에 둘까?” 같은 걸 매번 결정해야 함.
- 테스트할 때 라우트/서비스에 붙은 의존성을 직접 만들거나 mock 해줘야 해서, 규모가 커질수록 부담이 커짐.

NestJS는 **“우리 프레임워크가 정한 계층(모듈 → 컨트롤러 → 서비스)과 DI를 쓰면, 구조가 비슷해지고 테스트·교체가 쉬워진다”**는 전제 위에 설계돼 있어요. 즉, “자유도”를 조금 줄고 “일관성·유지보수성”을 늘리는 선택이에요.

---

## 2. NestJS의 주요 특징 (원리 위주)

### 2.1 계층이 정해진 구조 (Layered Architecture)

- **모듈(Module)**: 기능 단위로 묶는 상자. 컨트롤러·서비스·Repository 등을 한 덩어리로 export/import.
- **컨트롤러(Controller)**: HTTP 요청을 받아서 **어떤 서비스를 부를지**만 정함. 비즈니스 로직은 넣지 않는 게 원칙.
- **서비스(Service)**: 실제 비즈니스 로직·트랜잭션 조율. DB 접근은 보통 Repository에 위임.

**왜 이렇게 나누나?**  
한 곳(컨트롤러)에 라우팅·검증·비즈니스 로직·DB 접근이 다 있으면, 테스트할 때 “HTTP만 mock 할까, DB까지 mock 할까?”가 애매해져요. 계층을 나누면 “서비스만 단위 테스트”“컨트롤러는 서비스만 mock”처럼 **테스트 단위가 명확**해져요.

### 2.2 의존성 주입 (DI)

- 생성자에 `PostService`, `PostRepository` 같은 타입만 선언하면, Nest가 **실제 인스턴스를 알아서 넣어 줌**.
- 테스트 시에는 `PostService`를 mock 객체로 바꿔서 주입할 수 있음 → 컨트롤러/서비스 테스트가 DB 없이 가능.

**왜 DI인가?**  
`new PostService()`를 컨트롤러 안에서 직접 하면, “PostService가 내부적으로 뭘 쓰는지”까지 컨트롤러가 알게 되고, 나중에 DB를 바꾸거나 캐시를 붙이려면 컨트롤러 코드도 손대야 해요. DI는 “필요한 타입만 선언하고, 실제 구현은 프레임워크가 연결”하게 해서 **결합도를 낮추는** 목적이에요.

### 2.3 데코레이터 + TypeScript

- `@Controller()`, `@Get()`, `@Body()`, `@Param()` 등으로 **라우트·파라미터·바디**를 선언적으로 표시.
- 클래스·메서드 단위로 메타데이터가 붙기 때문에, Nest가 실행 시점에 “이 메서드는 GET /posts 에 대응한다”처럼 해석할 수 있어요.

**왜 데코레이터인가?**  
Express는 `app.get('/posts', handler)` 처럼 **함수 호출**로 라우트를 등록해요. Nest는 “이 클래스의 이 메서드가 이 경로다”를 **클래스/메서드에 붙은 표시**로 표현해서, 라우트와 핸들러가 한곳에 모이고, 나중에 권한·로깅 같은 걸 데코레이터나 미들웨어로 일괄 적용하기 쉽게 만들려는 거예요.

### 2.4 파이프·가드·인터셉터

- **파이프(Pipe)**: 요청 바디/쿼리/파라미터를 **변환·검증**. 실패 시 자동으로 400 등 반환. (예: `ValidationPipe` + class-validator)
- **가드(Guard)**: “이 라우트는 인증/권한이 있어야 한다”를 **boolean**으로 판단. 실패 시 401/403.
- **인터셉터(Interceptor)**: 요청 전/응답 후에 로깅·변환·타임아웃 등을 끼워 넣음.

Express에서도 미들웨어로 비슷하게 할 수 있지만, Nest는 “라우트·컨트롤러·메서드 단위로” 걸 수 있어서 **적용 범위를 세밀하게** 나누기 좋아요.

---

## 3. Express와 비교 표

| 구분                | Express                                                   | NestJS                                                                            |
| ------------------- | --------------------------------------------------------- | --------------------------------------------------------------------------------- |
| **구조**            | 자유형. 폴더/아키텍처를 직접 정함.                        | 모듈·컨트롤러·서비스로 **계층이 정해져 있음**. 팀 단위로 일관된 구조 유지에 유리. |
| **의존성 주입**     | 없음. 필요하면 직접 연결.                                 | **내장 DI**. 테스트 시 mock 치환, 결합도 낮추기 쉬움.                             |
| **타입/데코레이터** | JS 위주. TS 쓰려면 직접 세팅.                             | **TS·데코레이터 기반**. 라우트·검증·엔티티를 선언적으로 작성.                     |
| **라우팅**          | `app.get/post/use(...)` 로 등록.                          | `@Controller()` + `@Get()` 등 데코레이터로 클래스에 붙여서 표현.                  |
| **적합한 경우**     | 소규모 API, 빠른 프로토타입, 구조보다 유연성이 중요할 때. | 중규모 이상, 팀 개발, 유지보수·테스트를 오래 할 서비스.                           |

NestJS는 내부적으로 Express(또는 Fastify)를 쓰기 때문에, **“Express 위에 구조와 규칙을 얹은 프레임워크”**라고 보면 돼요. Express의 “아무거나 끼워 넣을 수 있는” 유연함은 줄어들고, 대신 **일관된 아키텍처·DI·TS**로 장기 프로젝트에 맞춰진 거예요.

---

## 4. 한계·주의할 점

- **학습 곡선**: 데코레이터·모듈·DI 개념을 알아야 해서, Express만 쓰던 사람은 처음에 “왜 이렇게 돌리지?” 싶을 수 있음.
- **소규모/1회성 API**: 규모가 작고 “빨리 하나 만들고 끝”이면 Express가 더 단순할 수 있음.
- **완전한 자유도**: “우리 팀만의 특이한 구조”를 고집하면 Nest의 규칙과 충돌할 수 있어요. Nest 스타일을 받아들일 때 이점이 커짐.

---

## 5. 정리

- NestJS는 **“구조와 DI를 프레임워크가 제공해서, 팀이 비슷한 방식으로 개발·테스트하기 쉽게 하자”**는 목적이에요.
- Express와의 차이는 **자유도 vs 일관성** 트레이드오프에 가깝고, 프로젝트 규모·기간·팀 크기에 따라 선택하면 돼요.
