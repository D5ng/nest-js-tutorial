# TypeORM vs Prisma 비교

두 ORM이 **어떤 방식**으로 DB를 다루는지, **왜** 그런 설계가 나왔는지, NestJS와 함께 쓸 때 어떤 차이가 있는지 정리한 문서예요.

---

## 1. 같은 목표, 다른 접근

둘 다 “객체(클래스/타입)와 DB 테이블을 맞추고, 타입 안전하게 쿼리하고, 마이그레이션을 관리하고 싶다”는 목표는 비슷해요.  
차이는 **스키마를 어디에, 어떤 형태로 정의하느냐**와 **쿼리 스타일**이에요.

- **TypeORM**: 스키마를 **TypeScript 클래스 + 데코레이터**로 정의. 런타임에 그 클래스를 읽어서 SQL로 바꿈.
- **Prisma**: 스키마를 **`schema.prisma`**라는 전용 파일(DSL)로 정의. **코드 생성**으로 타입과 클라이언트를 만들어서, 앱에서는 그 생성된 코드만 씀.

그래서 “스키마의 출처가 코드(클래스)인가, 별도 파일(prisma)인가”가 설계의 출발점이에요.

---

## 2. TypeORM 요약

### 2.1 엔티티·데코레이터 기반

- `@Entity()`, `@Column()`, `@ManyToOne()` 등으로 **클래스 = 테이블**로 매핑.
- NestJS의 컨트롤러·서비스·데코레이터 스타일과 잘 맞아서, “Nest처럼 하나의 언어(TS) 안에서 다 한다”는 느낌.

### 2.2 NestJS 연동

- `@nestjs/typeorm`으로 모듈에 `TypeOrmModule.forFeature([Post])` 식으로 등록.
- `Repository<Post>`를 서비스에 **주입**해서 쓰면 됨. Nest의 DI·Repository 패턴과 자연스럽게 연결됨.

### 2.3 쿼리

- `repository.find()`, `findOne()`, `createQueryBuilder()` 등.
- 관계 로딩은 `relations` 옵션이나 QueryBuilder로 제어. 가끔 N+1, 로딩 타이밍을 신경 써야 할 때가 있음.

### 2.4 마이그레이션

- CLI로 마이그레이션 생성·실행. **DB 스키마와 엔티티 클래스를 서로 맞추는 작업**을 직접 해줘야 해요. 엔티티를 바꾸면 마이그레이션을 만들고, DB에 적용하는 흐름.

**왜 이렇게 설계했나?**  
“스키마도 TypeScript로 하고, 런타임에 같은 클래스를 쓰자”는 철학이에요. 그래서 Nest·데코레이터·DI 한 세트와 잘 맞지만, 스키마가 코드와 DB 양쪽에 흩어져 있어서 **한쪽만 바꾸면 불일치**가 나기 쉽고, 그걸 마이그레이션으로 맞추는 책임이 개발자에게 있어요.

---

## 3. Prisma 요약

### 3.1 스키마 파일 + 코드 생성

- `schema.prisma`에 모델(테이블), 관계, 인덱스 등을 정의.
- `prisma generate`로 **타입 + Client**를 생성. 앱에서는 이 생성된 Client만 사용.

**왜 코드 생성인가?**  
스키마를 “단일 출처(single source of truth)”로 두고, 그걸 기준으로 타입과 API를 **자동 생성**하면, 스키마와 타입이 어긋날 여지가 줄어들어요. 대신 “스키마 변경 → generate 다시 돌리기”가 개발 흐름에 들어가요.

### 3.2 NestJS 연동

- `PrismaService`를 만들어서 `OnModuleInit`에서 `$connect()` 호출, `OnModuleDestroy`에서 `$disconnect()` 호출하는 식으로 쓰면 됨. 공식 예제도 이 패턴.
- DI로 `PrismaService`를 주입해서 `this.prisma.post.findMany()`처럼 사용. Repository 패턴을 쓰려면 그 위에 한 겹 더 감싸면 됨.

### 3.3 쿼리

- `include` / `select`로 **선언적으로** “이 관계까지 가져와라”를 적어줌. 타입이 그대로 추론되고, N+1을 피하기 위한 패턴이 문법에 녹아 있음.
- 쿼리 결과 타입이 스키마에서 생성되기 때문에 **타입 안전성**이 잘 지켜지는 편이에요.

### 3.4 마이그레이션

- `prisma migrate dev`로 스키마 변경분을 마이그레이션 파일로 만들고 DB에 적용. 툴링이 정돈돼 있고, “스키마 → 마이그레이션 → DB” 흐름이 명확해요.

---

## 4. 비교 표

| 구분             | TypeORM                                                                   | Prisma                                                                             |
| ---------------- | ------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| **스키마 정의**  | 엔티티 클래스 + 데코레이터 (`@Entity`, `@Column` 등).                     | **스키마 파일** `schema.prisma`. 코드 생성으로 타입·클라이언트 생성.               |
| **NestJS 연동**  | `@nestjs/typeorm` 으로 모듈에 통합. Repository 패턴, DI 와 잘 맞음.       | `PrismaService` 주입. 공식 패턴 있음. Repository는 원하면 그 위에 직접 구현.       |
| **쿼리**         | QueryBuilder, Repository 메서드, Raw SQL. 관계는 `relations` 등으로 제어. | **선언적** `include` / `select`. 타입 추론 좋고, N+1 회피 패턴이 문법에 녹아 있음. |
| **마이그레이션** | CLI로 생성·실행. 엔티티와 DB 스키마를 개발자가 맞춰야 함.                 | `prisma migrate`. 스키마가 단일 출처. 툴링이 정돈돼 있음.                          |
| **타입**         | 엔티티 클래스 = 타입. 런타임에 같은 클래스 사용.                          | 스키마에서 생성된 타입 사용. 스키마와 타입 불일치 가능성 적음.                     |
| **적합한 경우**  | Nest·데코레이터·Repository 패턴에 익숙할 때, 기존 TypeORM 경험 활용.      | 새 프로젝트, 팀이 Prisma 문법을 선호할 때, 타입·DX·마이그레이션 툴 중시.           |

---

## 5. 한계·주의할 점

### TypeORM

- 엔티티와 DB 스키마가 따로 관리되므로, 한쪽만 수정하면 **불일치**가 날 수 있음. 마이그레이션 습관이 중요.
- 관계 로딩·N+1을 피하려면 `relations`/QueryBuilder 사용 방식을 익혀야 함.
- 대규모 스키마에서 데코레이터와 런타임 리플렉션 비용을 신경 쓰는 팀도 있음 (보통은 미미).

### Prisma

- “스키마 파일 → generate” 단계가 빌드/배포 파이프라인에 들어감. generate 빼먹으면 타입과 런타임이 어긋날 수 있음.
- Nest의 “Repository를 인터페이스로 두고 DI로 교체” 패턴을 쓰려면, PrismaService 위에 Repository 레이어를 직접 설계해야 함.
- 일부 복잡한 Raw SQL·DB 특화 기능은 Prisma가 직접 지원하지 않아서, `$queryRaw` 등으로 우회할 때가 있음.

---

## 6. 정리

- **TypeORM**: “스키마도 TS 클래스로, Nest와 한 세트로” 쓰기 좋음. Repository·DI와 잘 맞고, 제어권이 넓은 대신 스키마·마이그레이션·관계 로딩을 직접 챙겨야 함.
- **Prisma**: “스키마를 한곳에서 관리하고, 타입·클라이언트는 생성”하는 방식. 타입 안전성·마이그레이션·쿼리 DX가 좋은 대신, Nest 스타일의 Repository 추상화는 원하면 직접 올려야 함.

이 프로젝트는 **TypeORM**을 쓰고 있어요. Nest 모듈·엔티티 데코레이터·Repository 패턴을 한 흐름으로 익히기 좋기 때문이에요.
