# class-validator vs nest-zod 비교

NestJS에서 **요청 바디·쿼리·파라미터를 검증**할 때 쓰는 두 가지 방식인 class-validator(데코레이터)와 nest-zod(Zod 스키마)의 차이를, **왜** 그런 설계인지 중심으로 정리한 문서예요.

---

## 1. 같은 목표, 다른 출발점

둘 다 “들어오는 데이터가 우리가 기대하는 형태인지 **런타임에 검증**하고, 틀리면 400 같은 응답을 돌려주자”는 목표는 같아요.  
차이는 **검증 규칙을 어디에, 어떤 형태로 정의하느냐**에요.

- **class-validator**: **DTO 클래스**에 `@IsString()`, `@MinLength()` 같은 **데코레이터**로 규칙을 붙임. Nest의 `ValidationPipe`가 이 클래스를 기준으로 검증.
- **nest-zod (nestjs-zod)**: **Zod 스키마**로 규칙을 정의. `ZodValidationPipe`가 스키마로 검증하고, 필요하면 `createZodDto()`로 DTO 클래스를 만들어 Nest와 맞춤.

즉, “클래스 + 데코레이터” vs “스키마(객체) 한 덩어리”의 차이예요.

---

## 2. class-validator 요약

### 2.1 데코레이터 기반 DTO

- DTO 클래스의 **프로퍼티**에 `@IsString()`, `@IsNumber()`, `@MinLength()`, `@IsOptional()` 등을 붙임.
- Nest의 `ValidationPipe`가 요청 바디(또는 쿼리/파라미터)를 **그 클래스 인스턴스로 변환**한 뒤, class-validator로 검증. 실패 시 자동으로 400 + 에러 메시지.

**왜 데코레이터인가?**  
Nest가 컨트롤러·라우트를 데코레이터로 표현하는 것과 같은 맥락이에요. “이 필드는 문자열이어야 한다”를 **타입 옆에 선언**해 두면, 라우트·DTO가 한 파일 안에 모이고, Nest 생태계(ValidationPipe, Swagger 등)와 바로 연동돼요.

### 2.2 장점

- Nest 공식 문서·예제에서 많이 쓰는 방식이라 자료가 많음.
- DTO = 클래스이기 때문에, **Swagger/OpenAPI**와 `@ApiProperty()` 등으로 잘 맞물림.
- “클래스 하나 = 요청 하나”라서, 컨트롤러에서 `@Body() dto: CreatePostDto`처럼 타입만 선언하면 됨.

### 2.3 단점

- 필드가 많아지면 **데코레이터가 많이** 붙어서 “데코레이터 지옥”처럼 느껴질 수 있음.
- **타입**과 **검증 규칙**이 분리돼 있음. `number`라고 타입만 써도, 실제로는 `@IsNumber()`를 안 붙이면 런타임 검증이 안 되기 때문에, 타입과 검증이 어긋날 여지가 있음.
- 복잡한 조건(예: “A가 있으면 B는 필수”)은 커스텀 데코레이터나 `@ValidateIf` 등으로 처리해야 해서, 스키마 한 번에 보기보다 다소 흩어질 수 있음.

---

## 3. nest-zod (nestjs-zod) 요약

### 3.1 Zod 스키마 + Nest 연동

- **Zod**로 스키마를 정의. 예: `z.object({ title: z.string().min(1), content: z.string() })`.
- **nestjs-zod**가 제공하는 `ZodValidationPipe`로 “이 라우트의 body는 이 스키마”를 지정. 스키마가 **단일 출처**가 됨.
- 필요하면 `createZodDto(schema)`로 **DTO 클래스를 생성**해서, Nest의 `@Body()` 타입이나 Swagger와 맞출 수 있음.

**왜 스키마인가?**  
Zod 스키마는 “한 객체”로 “타입 + 검증 규칙”을 같이 정의해요. 그래서 **타입과 검증이 한곳**에서 나와서, “타입은 맞다고 했는데 검증은 안 했다” 같은 불일치가 줄어들어요. Prisma의 스키마가 “한 파일에서 타입·API를 생성”하는 것과 비슷한 철학이에요.

### 3.2 nestjs-zod가 주는 것

- **ZodValidationPipe**: body·query·param을 Zod 스키마로 검증. 실패 시 400 + Zod 에러 메시지.
- **createZodDto**: Zod 스키마 → DTO 클래스. Nest의 `@Body()` 타입·Swagger와 연동할 때 사용.
- **ZodSerializerInterceptor**: 응답 바디도 스키마로 검증/직렬화할 수 있음.
- **OpenAPI/Swagger**: Zod 스키마에서 API 문서를 자동 생성하는 연동도 지원.

### 3.3 장점

- **스키마 한 덩어리**로 타입·검증·(선택) 문서가 같이 관리됨. 복잡한 조건(조건부 필수, refine 등)도 Zod 문법으로 한곳에 쓸 수 있음.
- Zod에 익숙한 팀은 “데코레이터 여러 개”보다 **스키마 객체**가 읽기 편할 수 있음.
- 타입 추론이 Zod에서 나오기 때문에, “타입은 맞는데 검증 데코레이터를 깜빡했다” 같은 실수가 줄어듦.

### 3.4 단점

- Nest 기본 문서는 class-validator 기준이라, nest-zod는 **서드파티** 흐름을 따름. 팀이 Nest만 알면 처음에 설정·사례를 찾아봐야 함.
- DTO를 **클래스**로 쓰고 싶으면 `createZodDto()` 단계가 필요. 스키마만 쓰고 DTO 클래스는 안 쓰는 패턴도 가능하지만, Swagger/`@Body()` 타입과 맞추는 방식은 팀 규칙이 필요함.

---

## 4. 비교 표

| 구분                | class-validator                                                            | nest-zod (nestjs-zod)                                              |
| ------------------- | -------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| **검증 정의**       | DTO **클래스** + 데코레이터 (`@IsString()`, `@MinLength()` 등).            | **Zod 스키마** (`z.object({ ... })`). 스키마가 단일 출처.          |
| **타입과 검증**     | 타입(TS)과 검증(데코레이터)이 **분리**. 데코레이터 누락 시 검증 누락 가능. | 스키마에서 **타입·검증 동시** 추론. 타입과 검증 불일치 적음.       |
| **Nest 연동**       | `ValidationPipe` (내장) + `class-transformer`. 공식 문서·예제 다수.        | `ZodValidationPipe` + (선택) `createZodDto`. 서드파티.             |
| **복잡한 조건**     | `@ValidateIf`, 커스텀 데코레이터 등으로 처리. 다소 흩어질 수 있음.         | Zod `refine`/`superRefine`/조건 분기로 **스키마 한곳**에서 처리.   |
| **Swagger/OpenAPI** | `@ApiProperty()` 등으로 DTO와 매핑.                                        | Zod 스키마 기반 문서 생성 지원.                                    |
| **적합한 경우**     | Nest 기본 스타일 유지, 데코레이터·클래스에 익숙할 때.                      | Zod·스키마 중심에 익숙할 때, 타입·검증 일치·복잡 검증을 중시할 때. |

---

## 5. 한계·주의할 점

### class-validator

- **타입만 있고 검증 데코레이터를 안 붙인** 필드가 있으면, 런타임에는 검증이 안 되는데 타입상으로는 “다 된 것”처럼 보일 수 있음. 팀 규칙(예: DTO는 반드시 데코레이터)으로 맞춰야 함.
- 조건부 검증·필드 간 의존이 많아지면 데코레이터가 여러 개로 흩어져서, “이 DTO의 전체 규칙”을 한눈에 보기 어려울 수 있음.

### nest-zod

- Nest 생태계에서 **기본**은 아니므로, 팀원이 Nest만 알면 “Zod는 뭐고, Pipe는 왜 이걸 쓰지?”부터 설명이 필요할 수 있음.
- `createZodDto()` 사용 여부, Swagger와 어떻게 연결할지 등 **패턴을 팀에서 정해** 두는 게 좋음.

---

## 6. 정리

- **class-validator**: Nest와 같은 **클래스·데코레이터** 스타일. 공식 문서와 잘 맞고, DTO 하나당 클래스 하나로 정리되지만, 타입과 검증이 분리돼 있어서 규칙을 꼼꼼히 맞춰야 함.
- **nest-zod**: **Zod 스키마**를 단일 출처로 두고, 타입·검증·(선택) 문서를 한 흐름으로 가져감. Zod에 익숙하고 “스키마 한 덩어리”를 선호하면 유리하고, Nest 기본 스타일과는 다른 선택이에요.

이 프로젝트는 **class-validator**를 쓰고 있어요. Nest 기본 스타일과 TypeORM·데코레이터 흐름을 맞추기 위해서예요. 나중에 Zod·스키마 중심으로 바꾸고 싶다면 nest-zod로 전환하는 것도 가능해요.
